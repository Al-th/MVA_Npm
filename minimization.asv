init;
setupData;

nbNeighbors = 20;
iterMax = 250;
dMax = 1;

%%

tic
covA = getCov(A, nbNeighbors);
covB = getCov(B, nbNeighbors);
toc

%%
transformation0 = zeros(6,1);
transformation0(1) = degtorad(20);
transformation0(2) = degtorad(15);
transformation0(3) = degtorad(65);

transformation = transformation0;
for i = 1:iterMax
    M = computeTransformationMatrixFromParams(transformation);
    
    A_trans = transformPointCloud(A,M);
    
    %Find the closest point b <=> T*ai
    % idx t.q A = B(idx);
    tree = kdtree_build(B_trans);
    closestPointIndex = zeros(size(A,1),1);
    for j = 1:size(A,1)
        idx = kdtree_k_nearest_neighbors(tree,A_trans(j,:),1);
        closestPointIndex(j) = idx;
    end
    
    %Remove from set points that are too far
    % if abs(A - B(idx)) < dMax : on garde
    % fill the param (points, normals, covar);
    param{1}.point = zeros(size(A,1),size(A,2));
    param{1}.cov = zeros(size(A,1),9);
    
    param{2}.point = zeros(size(B,1),size(B,2));
    param{2}.cov = zeros(size(A,1),9);
    
    nbSubset = 0;
    for j = 1:size(A,1)

        distanceBetweenPair = norm(A((closestPointIndex(j) - p2(1:3),2);
        if(distanceBetweenPair < dMax)
           nbSubset = nbSubset + 1;
           param{1}.point(nbSubset,:) = A((closestPointIndex(j),:);
           param{2}.point(nbSubset,:) = B(j),:);
           
           param{1}.cov(nbSubset,:) = covA((closestPointIndex(j),:);
           param{2}.cov(nbSubset,:) = covB(j),:);
        end
    end
    % Reduce param to subset only
    param{1}.point = param{1}.point(1:nbSubset,:);
    param{2}.point = param{2}.point(1:nbSubset,:);
    param{1}.cov = param{1}.cov(1:nbSubset,:);
    param{2}.cov = param{2}.cov(1:nbSubset,:);
    
    f = @(x)costFunction(x,param);
    
    hybridOptions =optimset('Display','iter','LargeScale','off','MaxFunEvals',100);
    
    [transformation, cost] = fminunc(f,transformation,hybridOptions);
    
    N = computeTransformationMatrixFromParams(transformation);
    B = N(1:3,1:3)
    
    
end